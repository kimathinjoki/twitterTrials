# -*- coding: utf-8 -*-
"""twitterTrial.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UtgqAiIAuL7_2g3bwWlNowHYXMDmzgbO
"""

from tweepy.streaming import StreamListener
from tweepy import OAuthHandler
from tweepy import Stream
from tweepy import Cursor
from tweepy import API
import numpy as np
import pandas as pd


from textblob import TextBlob
import re

# from google.colab import drive
# drive.mount('/content/drive')

# files.download('cridential.ipynb')

# from cridential import Cridential


 # the user is nione because we've not specified so likely it will go to my tl, specify the user at the none area
class TwitterClients():
    def __init__(self, twitter_user=None):
        self.auth = TwitterAuthenticator().authenticate_twitter_app()
        self.twitter_client = API(self.auth)

        self.twitter_user = twitter_user


    def get_twitter_client_api(self):
        return self.twitter_client
    

    def get_user_timeline_tweets(self,num_tweets):
        tweets = [] 
        for tweet in Cursor(self.twitter_client.user_timeline, id=self.twitter_user).items(num_tweets):
            tweets.append(tweet)
        return tweets

    def get_friends_list(self, num_friends):
        friend_list = []
        for friend in Cursor(self.twitter_client.friends,id=self.twitter_user).items(num_friends):
            friend_list.append(friend)
        return friend_list
    def get_home_timeline(self,num_tweets):
        home_timeline_tweets = []
        for tweet in Cursor(self.twitter_client.home_timeline, id=self.twitter_user).items(num_tweets):
            home_timeline_tweets.append(tweet)
        return home_timeline_tweets


    # twitter authenticator class
class TwitterAuthenticator():
    def authenticate_twitter_app(self):
        auth = OAuthHandler(Cridential.ConsumerKey, Cridential.ConsumerSecret)
        auth.set_access_token(Cridential.AccessToken, Cridential.AccessTokenSecret)

        return auth

class TwitterStreamer():

    def __init__(self):
        self.twitter_authenticator = TwitterAuthenticator()

    """
    class for streaming and processing live tweets.
    """
    def stream_tweets(self,fetched_tweets_filename, hashtag_list):
    #this hundles tweeter authentication and the connection to the  twiotter streaming API
        listener = TwitterListener(fetched_tweets_filename)
        auth = self.twitter_authenticator.authenticate_twitter_app()


        stream = Stream( auth, listener)

        stream.filter(track=hashtag_list)



class TwitterListener (StreamListener):
    """
    this a bsaic listener class that just prints recieved tweets to stdout.
    """
    def __init__(self, fetched_tweets_filename):
        self.fetched_tweets_filename = fetched_tweets_filename

    def on_data(self, data):
        try: 
            print(data)
            with open(self.fetched_tweets_filename, 'a') as tf:
                tf.write(data)
       
            return True
        except BaseException as e:
            print("Error on data:%s" %str(e))
        return True
 # prints out the Error
    def on_error(self, status):
        if status == 420:
            # return false on data incase rate limit occurs from twitter
            return False
        print(status)

 

class TweetAnalyzer():
  
    """
    Functionality for analyzing and categorizing content from tweets.
    """

    def clean_tweet(self, tweet):
        return ' '.join(re.sub("(@[A-Za-z0-9]+)|([^0-9A-Za-z \t])|(\w+:\/\/\S+)", " ", tweet).split())

    def analyze_sentiment(self, tweet):
        analysis = TextBlob(self.clean_tweet(tweet))
        
        if analysis.sentiment.polarity > 0:
            return 1
        elif analysis.sentiment.polarity == 0:
            return 0
        else:
            return -1


 # functionality for analyzing and categorizing content from tweets.

    def tweet_to_data_frame(self,tweets):
        df = pd.DataFrame(data=[tweet.text for tweet in tweets], columns=['Tweets'])


        df['id'] = np.array([tweet.id for tweet in tweets])
        df['len'] = np.array([len(tweet.text) for tweet in tweets])
        df['date'] = np.array([tweet.created_at for tweet in tweets])
        df['source'] = np.array([tweet.source for tweet in tweets])
        df['likes'] = np.array([tweet.favorite_count for tweet in tweets])
        df['retweets'] = np.array([tweet.retweet_count for tweet in tweets])

        return df


if __name__ == "__main__":

    # hashtag_list =["uhuru kenyatta", "covid19", "curfew", "ruto", "lockdown", "quarentine", "mutahi kagwe"]
    # fetched_tweets_filename ="tweets.json"


 # in the client bracket add the users you want
    twitter_client = TwitterClients()

    
    tweet_analyzer = TweetAnalyzer()

    api = twitter_client.get_twitter_client_api()

    tweets = api.user_timeline(screen_name="BarackObama", count=200)

   


# the below shows the part of the tweet
    #print(dir(tweets[0]))

#  the below line shows exactly what you lookig for in a tweet, id, location, time
    #print(tweets[0].retweet_count)

    df = tweet_analyzer.tweet_to_data_frame(tweets)
    df['sentiment'] = np.array([tweet_analyzer.analyze_sentiment(tweet) for tweet in df['Tweets']])


    print(df.head(20))



df.likes.max()

import matplotlib.pyplot as plt

time_likes =pd.Series(data=df['likes'].values, index=df['date'])
time_likes

time_likes.plot(figsize=(18,5), color='r')
plt.show

# Layered Time Series:
time_likes = pd.Series(data=df['likes'].values, index=df['date'])
time_likes.plot(figsize=(16, 4), label="likes", legend=True)

time_retweets = pd.Series(data=df['retweets'].values, index=df['date'])
time_retweets.plot(figsize=(16, 4), label="retweets", legend=True)
plt.show()
